import os
import sys
import asyncio
from aiogram import Bot, Dispatcher, types
from aiogram.enums import ParseMode
from aiogram.filters import Command
from fastapi import FastAPI, Request
from dotenv import load_dotenv
import requests
import openai

# --- –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Å—Ä–µ–¥—ã ---
load_dotenv()

def get_env_str(name, required=True, default=None):
    val = os.getenv(name)
    if val is None or val == "":
        if required:
            print(f"Environment variable {name} is not set! Please set it in your Railway/Heroku/.env")
            sys.exit(1)
        return default
    return val

def get_env_int(name, required=True, default=None):
    val = get_env_str(name, required, default)
    try:
        return int(val)
    except Exception:
        print(f"Environment variable {name} must be integer-like, got: {val}")
        sys.exit(1)

BOT_TOKEN = get_env_str("BOT_TOKEN")
OPENAI_API_KEY = get_env_str("OPENAI_API_KEY")
CHAT_ID = get_env_int("CHAT_ID")           # –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û —Å –º–∏–Ω—É—Å–æ–º –¥–ª—è —Å—É–ø–µ—Ä–≥—Ä—É–ø–ø!
THREAD_ID = get_env_int("THREAD_ID")
OWNER_ID = 196614680                       # –ó–∞–º–µ–Ω–∏ –Ω–∞ —Å–≤–æ–π user_id –µ—Å–ª–∏ –Ω—É–∂–Ω–æ

bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()
app = FastAPI()
openai_client = openai.OpenAI(api_key=OPENAI_API_KEY)

BITRIX_WEBHOOK_URL = "https://nebar.bitrix24.ru/rest/1856/5damz451340uegoc/"

def get_tasks_list(limit=5):
    url = BITRIX_WEBHOOK_URL + "tasks.task.list"
    params = {
        "select": ["ID", "TITLE", "DESCRIPTION", "RESPONSIBLE_NAME", "CREATED_BY", "DEADLINE"],
        "order": {"DEADLINE": "asc"},
        "filter": {}
    }
    resp = requests.get(url, params=params)
    data = resp.json()
    if "result" in data and "tasks" in data["result"]:
        return data["result"]["tasks"][:limit]
    return []

def is_private_owner(message: types.Message):
    return message.chat.type == "private" and message.from_user.id == OWNER_ID

def is_work_thread(message: types.Message):
    return (
        message.chat.type in ("supergroup", "group")
        and message.chat.id == CHAT_ID
        and message.message_thread_id == THREAD_ID
    )

@dp.message(Command("b24tasks"))
async def show_b24tasks(message: types.Message):
    if not (is_private_owner(message) or is_work_thread(message)):
        return
    tasks = get_tasks_list(limit=5)
    if not tasks:
        await message.reply("–ù–µ—Ç –∑–∞–¥–∞—á –≤ –ë–∏—Ç—Ä–∏–∫—Å24.")
        return
    msg = "<b>–¢–æ–ø –∑–∞–¥–∞—á –∏–∑ –ë–∏—Ç—Ä–∏–∫—Å24:</b>\n"
    for task in tasks:
        t = task["task"]
        title = t.get("title", "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è")
        tid = t.get("id", "-")
        responsible = t.get("responsible_name", "-")
        deadline = t.get("deadline", "–Ω–µ —É–∫–∞–∑–∞–Ω")
        msg += f"\n<b>{title}</b>\nID: <code>{tid}</code>\n–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π: {responsible}\n–î–µ–¥–ª–∞–π–Ω: {deadline}\n"
        msg += f'<a href="https://nebar.bitrix24.ru/company/personal/user/{t.get("created_by", "")}/tasks/task/view/{tid}/">–û—Ç–∫—Ä—ã—Ç—å –∑–∞–¥–∞—á—É</a>\n'
    await message.reply(msg, parse_mode=ParseMode.HTML, disable_web_page_preview=True)

@dp.message(Command("gpt"))
async def gpt_answer(message: types.Message):
    if not (is_private_owner(message) or is_work_thread(message)):
        return
    user_text = message.text.replace("/gpt", "", 1).strip()
    if not user_text:
        await message.reply("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã /gpt")
        return
    try:
        response = openai_client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": "–¢—ã –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π Telegram-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç, –æ—Ç–≤–µ—á–∞–π –∫—Ä–∞—Ç–∫–æ –∏ –ø–æ –¥–µ–ª—É."},
                {"role": "user", "content": user_text}
            ],
            max_tokens=500,
            temperature=0.7,
        )
        answer = response.choices[0].message.content
        await message.answer(answer)
    except Exception as e:
        await message.reply(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ AI: {e}")

@dp.message()
async def fallback(message: types.Message):
    if is_private_owner(message) or is_work_thread(message):
        await message.reply("–ï—Å–ª–∏ —Ö–æ—á–µ—à—å —Å–ø—Ä–æ—Å–∏—Ç—å —É GPT, –∏—Å–ø–æ–ª—å–∑—É–π /gpt [—Ç–µ–∫—Å—Ç]")

@app.post("/bitrix-webhook")
async def bitrix_webhook(request: Request):
    try:
        data = await request.json()
        task = (
            data.get("task") or
            data.get("data", {}).get("TASK") or
            data
        )
        if not task:
            return {"ok": False, "error": "No task data"}
        title = task.get("title", "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è")
        desc = task.get("description", "-")
        task_id = task.get("id", "‚Äî")
        deadline = task.get("deadline", "–Ω–µ —É–∫–∞–∑–∞–Ω")
        responsible = (
            task.get("responsible", {}).get("name")
            if isinstance(task.get("responsible"), dict)
            else task.get("responsible", "-")
        )
        creator = (
            task.get("creator", {}).get("name")
            if isinstance(task.get("creator"), dict)
            else task.get("creator", "-")
        )
        creator_id = (
            task.get("creator", {}).get("id")
            if isinstance(task.get("creator"), dict)
            else ""
        )
        link = f"https://nebar.bitrix24.ru/company/personal/user/{creator_id}/tasks/task/view/{task_id}/"
        message_text = (
            f"üÜï <b>–ù–æ–≤–∞—è –∑–∞–¥–∞—á–∞ –∏–∑ Bitrix24</b>\n"
            f"<b>–ù–∞–∑–≤–∞–Ω–∏–µ:</b> {title}\n"
            f"<b>–û–ø–∏—Å–∞–Ω–∏–µ:</b> {desc}\n"
            f"<b>–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å:</b> {responsible}\n"
            f"<b>–ü–æ—Å—Ç–∞–Ω–æ–≤—â–∏–∫:</b> {creator}\n"
            f"<b>–î–µ–¥–ª–∞–π–Ω:</b> {deadline}\n"
            f'<a href="{link}">–û—Ç–∫—Ä—ã—Ç—å –∑–∞–¥–∞—á—É –≤ –ë–∏—Ç—Ä–∏–∫—Å24</a>'
        )
        send_kwargs = dict(
            chat_id=CHAT_ID,
            text=message_text,
            parse_mode=ParseMode.HTML,
            disable_web_page_preview=True
        )
        if THREAD_ID:
            send_kwargs["message_thread_id"] = THREAD_ID
        asyncio.create_task(bot.send_message(**send_kwargs))
        return {"ok": True}
    except Exception as e:
        return {"ok": False, "error": str(e)}

async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    import uvicorn
    loop = asyncio.get_event_loop()
    loop.create_task(main())
    uvicorn.run(app, host="0.0.0.0", port=8000)
